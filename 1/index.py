# Главная особенность python - это краткость и предельная простота кода.
# Python был создан Гвидо ван Россумом 20 февраля 1991

# Создатель языка, Гвидо ван Россум, был поклонником Британского комедийного шоу 
# «Летающий цирк Монти Пайтона». Вот и (Monty Python)» язык назвался Python

# Переменная - это именованный контейнер для заданного значения.

# Пример создания переменных
# age = 19
# name = 'Ivan'
# isActive = True
# name = 'Petr'
# Name = 'Ivan'
# name и Name - это разные переменные
# Имена переменных не могут начинаться с цифры!
# В Python есть 4 примитивных типа данных:
# int (целые числа)
# age = 18
# float (дробные числа)
# fraction = 2.5
# str (строки)
# fruit = 'apple'
# bool (правда или ложь)
# isReady = True # всего два значения: True и False
# Мы можем преобразовывать один тип данных в другой с помощью одноименных функций. 
# Например, число может стать строкой, строка - числом, дробное число - целым.
# age = '22' # str -> '22'
# age = int(age) # int -> 22
# age = float(age) # float -> 22.0
# age = bool(age) # bool -> True
# Функция print() выводит данные на экран.
# name = 'Alexey'
# В скобках записываются переданные в функцию параметры
# print(name)
# Вывод
# >> Alexey
# Функция print() может принимать несколько входных параметров.
# print(1, 2, 3)
# Вывод
# >> 1 2 3
# Каждый print() выводит данные на новой строке. 
# По умолчанию завершающий символ строки равен символу новой строки (\n).
# print('Hello')
# print('world')
# Вывод
# >> Hello
# >> world
# Завершающий символ строки в функции print() можно изменять.
# print('Hello', end=' ')
# print('world')
# Вывод
# >> Hello world
# Функция input() принимает пользовательский ввод данных.
# name = input()
# print('Hello ' + name)
# После запуска скрипта Python будет ожидать ввода данных
# Функция input может принимать всего лишь один аргумент - строку, 
# которая выведется перед входной строкой.
# name = input('Enter your name: ')
# print('Hello, ' + name)
# Данные, полученные с помощью функции input(), имеют строковый тип данных (str).
# Строки можно складывать друг с другом, такое сложение называется их конкатенацией или объединением.
# Сумма двух строчных чисел
# number1 = input('Введите число: ')
# number2 = input('Введите число: ')
# print(number1 + number2)
# Ввод:
# >> 1
# >> 2
# Вывод:
# >> 12
# Преобразуем строковый тип в целое число (str -> int).
# Исправленная сумма двух чисел
# number1 = int(input('Введите число: '))
# number2 = int(input('Введите число: '))
# print(number1 + number2)
# Ввод:
# >> 1
# >> 2
# Вывод: 
# 3

# В языке программирования Python есть арифметические, логические и операторы сравнения.
# Сложение:
# print(10 + 30)
# Вывод
# >> 40
# Вычитание
# print(30 - 20)
# Вывод
# >> 10
# Умножение:
# print(2 * 9)
# Вывод
# >> 18
# Деление
# print(100 / 25)
# Вывод
# >> 4

# Кроме всем знакомой четверки есть и несколько экзотических операторов: взятие остатка от 
# деления, деление нацело, возведение в степень.
# Взятие остатка от деления:
# Взятие остатка от деления на 2
# print(0 % 2)
# print(1 % 2)
# print(2 % 2)
# print(3 % 2)
# print(4 % 2)
# Вывод
# >> 0 # 0 % 2
# >> 1 # 1 % 2
# >> 0 # 2 % 2
# >> 1 # 3 % 2
# >> 0 # 4 % 2
# Взятие остатка от деления на 3
# print(0 % 3)
# print(1 % 3)
# print(2 % 3)
# print(3 % 3)
# print(4 % 3)
# print(5 % 3)
# print(6 % 3)
# Вывод
# >> 0 # 0 % 3
# >> 1 # 1 % 3
# >> 2 # 2 % 3
# >> 0 # 3 % 3
# >> 1 # 4 % 3
# >> 2 # 5 % 3
# >> 0 # 6 % 3
# Деление нацело:
# Деление нацело на 10
# print(91 // 10)
# print(85 // 10)
# print(16 // 10)
# print(8 // 10)
# Вывод
# >> 9 # 91 // 10
# >> 8 # 85 // 10
# >> 1 # 16 // 10
# >> 0 # 8 // 10
# Деление нацело на 2
# print(14 // 2)
# print(15 // 2)
# print(7 // 2)
# print(6 // 2)
# Вывод
# >> 7 # 14 // 2
# >> 7 # 15 // 2
# >> 3 # 7 // 2
# >> 3 # 6 // 2
# Возведение в степень:
# Возведение в степень числа 2
# print(2 ** 0) # 1
# print(2 ** 1) # 2
# print(2 ** 2) # 2 * 2
# print(2 ** 3) # 2 * 2 * 2
# print(2 ** 4) # 2 * 2 * 2 * 2
# Вывод
# >> 1
# >> 2
# >> 4
# >> 8
# >> 16
# Операторы сравнения (╮°-°)╮ могут возвращать всего два результата: True и False.
# Оператор равенства == возвращает True, если числа равны, и False в противном случае.
# a = 10
# b = 10
# print(a == b)
# Вывод
# >> True
# a = 8
# b = 7
# print(a == b)
# Вывод
# >> False
# Оператор неравенства != возвращает True, если числа не равны, и False в противном случае.
# a = 8
# b = 7
# print(a != b)
# Вывод
# >> True
# Оператор больше > возвращает True, если первое число больше второго, и False в противном случае.
# a = 8
# b = 7
# print(a > b)
# print(b > a)
# Вывод
# >> True # a > b
# >> False # b > a
# Оператор меньше < возвращает True, если первое число меньше второго, и False в противном случае.
# c = 100
# d = 200
# print(c < d)
# print(d < c)

# Вывод
# >> True # c < d
# >> False # d < c
# Оператор меньше или равно <= возвращает True, если первое число меньше второго или равно ему, 
# и False в противном случае.
# Оператор больше или равно >= возвращает True, если первое число больше второго или равно ему, 
# и False в противном случае.
# c = 200
# d = 200
# print(c >= d)
# print(d <= c)
# Вывод
# >> True # c >= d
# >> True # d <= c
# Иногда требуются выполнение нескольких операторов сравнения сразу. Для таких целей 
# существует оператор and (оператор логического умножения, конъюнкция).
# print(10 > 0 and 5 > 0)
# print(10 % 2 == 0 and 12 % 2 == 0) # оба числа четные
# Вывод:
# >> True
# >> True
# Если хотя бы один из операторов равен False, то результат оператора будет равен False. 
# Конъюкция истинна в том случае, когда все условия истинны.
# print(10 > 100 and 5 > 0 and 10 > 0) # False
# Вывод:
# >> False
# Логическое сложение (дизъюнкция) или оператор or требует выполнения ХОТЯ БЫ одного условия.
# print(10 > 100 or 5 > 100 or 10 > 0) # True
# print(1 == 0 or 2 == 0) # False, оба условия ложны
# Вывод:
# >> True
# >> False
# Последний из операторов - это оператор инверсии not. Оператор not изменяет 
# (инвертирует) значение на противоположное.
# print(not False) # True
# print(not True) # False
# print(not 2 == 0) # True
# Вывод:
# >> True
# >> False
# >> True
# Оператор not выполняется в приоритете.
# print(not 1 == 0 or 2 == 0) # True, значение первого условия инвертировано
# Вывод:
# >> True

# Условный оператор выполняет некоторое действие, если указанное условие истинно (равно True).
# Обратите внимание на отступ в четыре (4!) пробела
# или одну табуляцию (кнопочка TAB)
# if True: # Обязательное двоеточие перед блоком кода
    # print('Условие истинно, поэтому я напечатаюсь')
# Вывод
# >> Условие истинно, поэтому я напечатаюсь
# В условии любой тип данных неявно приводится к bool. Пустая строка и ноль равны False.
# print(bool(1)) # -> True
# print(bool(0)) # -> False
# print(bool(10.2)) # -> True
# print(bool('')) # -> False
# print(bool('Hello')) # -> True
# Если условие ложно, то код, находящийся под оператором if не выполнится.
# if 0: # Обязательное двоеточие перед блоком кода
    # print('Я никогда не напечатаюсь :(')
# Если условие в if ложно, то выполнится оператор под оператором else.
# if 0:
    # print('Я никогда не напечатаюсь :(')
# else:
    # print('Оператор else вступает в игру')
# Вывод
# >> Оператор else вступает в игру
# Иногда двух вариантов недостаточно, для этого существует оператор elif, а для все 
# остального есть...
# age = int(input())
# if age < 10:
    # print('Ваш возраст - это одна цифра :)')
# elif age < 15:
    # print('Удачи с геометрией :):):)')
# else:
    # print('Совсем взрослый уже :(')
# Если условие в операторе if ложно, то интерпретатор проверяет истинность условия операторов elif, 
# всех по очереди. Если все условия ложны, то выполнится оператор else.
# Примеры
# 1. Четное-нечетное
# Выведите строку 'четное', если введенное число четно, и строку 'нечетное', если число нечетно.
# a = int(input())
# if a % 2 == 0:
    # print('четное')
# else:
    # print('нечетное')
# Ввод
# >> 10
# Вывод
# >> четное
# Ввод
# >> 11
# Вывод
# >> нечетное
# 2. Много elif'ов
# Если в вашем коде больше трех elif значит что-то не так и стоит придумать новый алгоритм.
# Это сугубо академический пример, так писать не стоит.
# a = int(input('Введите число от одного до 1 до 100'))
# if a < 10:
    # print('Ваше число меньше 10')
# elif a < 20:
    # print('Ваше число меньше двадцатки')
# elif a < 30:
    # print('30 - это потолок')
# elif a < 40:
    # print('Ваше число меньше 40')
# elif a < 50:
    # print('Много, но не больше полтинника')
# elif a < 60:
    # print('Число меньше, чем шесть*десять')
# elif a < 70:
    # print('Ваше число расположено в восьмом десятке')
# elif a < 80:
    # print('Ваше число меньше 80')
# elif a < 90:
    # print('Ваше число находится в 9 десятке')
# elif a < 100:
    # print('Сотня больше вашего числа')
# else:
    # print('Хитро, но меня не обманешь, число слишком большое')
# Ввод
# >> 11
# Вывод
# >> Ваше число меньше двадцатки
# Ввод
# >> 91
# Вывод
# >> Сотня больше вашего числа
# Ввод
# >> 58
# Вывод
# >> Число меньше, чем шесть*десять
# 3. Белая или черная
# Пользователь вводит два числа: координаты шахматной клетки.
# Выведите YES, если клетка белая, и NO, если - черная.
# x = int(input('Введите координату x: '))
# y = int(input('Введите координату y: '))
# Идея такая: если четность координат совпадает,
# то это черная клетка, а если - нет, то белая.
# if (x + y) % 2 == 1:
    # print('YES')
# else:
    # print('NO')
# Ввод:
# >> 1
# >> 1
# Вывод:
# >> NO
# Ввод:
# >> 1
# >> 1
# Вывод:
# >> NO
# 4. Белая или черная (случайные координаты)
# Та же задача, но со случайными числами.
# Координаты шахматной клетки выбираются случайным образом
# Выведите YES, если клетка белая, и NO, если - черная.
# from random import randint # импортирование функции randint
# x = randint(1,8) # функция randint вернет случайное число от 1 до 8
# y = randint(1,8)
# print(x, y) # вывод пары случайных чисел
# if (x + y) % 2 == 1:
    # print('YES')
# else:
    # print('NO')

# Цикл в любом языке программирования - это многократное выполнение одного и то же действия.
# В Python все немного не так. Здесь цикл for - это цикл перебора последовательности. 
# Он состоит из двух компонент: переменной (переменных) цикла и последовательности. 
# Приведу пример:
# for item in 'one', 'two', 'three':
    # print(item)
# В приведенном выше примере переменная цикла item по очереди принимает каждое значение 
# последовательности, которая записана после служебного слова in. На первом повторении 
# переменная item равна строке 'one', на втором - строке 'two', на третьем - строке 'three'.
# Вывод:
# >> one
# >> two
# >> three
# Еще несколько примеров:
# for element in '1', 'hello', 2, 1990, True, False:
    # print(element)
# Вывод:
# >> 1
# >> hello
# >> 2
# >> 1990
# >> True
# >> False
# for letter in 'Hello world':
    # print(letter)
# >> H
# >> e
# >> l
# >> l
# >> o
# >> w
# >> o
# >> r
# >> l
# >> d
# Функция range()
# Функция range() возвращает диапазон (последовательность) целых чисел. 
# range() может принимать 1, 2 или 3 аргумента.
# Примеры функции range() с одним аргументом:
# range() с одним аргументом
# print('range(3) -> 0, 1, 2')
# for x in range(3): # range(3) -> 0, 1, 2
    # print(x)
# print('range(5) -> 0, 1, 2, 3, 4')
# for x in range(5): # range(5) -> 0, 1, 2, 3, 4
    # print(x)
# range(1) -> 0
# range(6) -> 0, 1, 2, 3, 4, 5
# range(10) -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
# Вывод:
# >> range(3) -> 0, 1, 2
# >> 0
# >> 1
# >> 2
# >> range(5) -> 0, 1, 2, 3, 4
# >> 0
# >> 1
# >> 2
# >> 3
# >> 4
# Примеры функции range() с двумя аргументами:
# print('range(3, 5) -> 3, 4')
# for x in range(3, 5): # range(3, 5) -> 3, 4
    # print(x)
# print('range(1, 5) -> 1, 2, 3, 4')
# for x in range(1, 5): # range(1, 5) -> 1, 2, 3, 4
    # print(x)
# range(2, 7) -> 2, 3, 4, 5, 6
# range(100, 105) -> 100, 101, 102, 103, 104
# range(50, 53) -> 50, 51, 52
# Вывод:
# >> range(3, 5) -> 3, 4
# >> 3
# >> 4
# >> range(1, 5) -> 1, 2, 3, 4
# >> 1
# >> 2
# >> 3
# >> 4

# Примеры функции range() с тремя аргументами:

# print('range(0, 10, 2) -> 0, 2, 4, 6, 8')
# for x in range(0, 10, 2): # range(0, 10, 2) -> 0, 2, 4, 6, 8
#     print(x)

# print('range(1, 10, 2) -> 1, 3, 5, 7, 9')
# for x in range(1, 10, 2): # range(1, 10, 2) -> 1, 3, 5, 7, 9
#     print(x)

# print('range(10, 20, 3) -> 10, 13, 16, 19')
# for x in range(10, 20, 3): # range(10, 20, 3) -> 10, 13, 16, 19
#     print(x)

# range(2, 7, 5) -> 2
# range(1, 8, 4) -> 1, 5
# range(4, 20, 5) -> 4, 9, 14, 19

# >> range(0, 10, 2) -> 0, 2, 4, 6, 8
# >> 0
# >> 2
# >> 4
# >> 6
# >> 8
# >> range(1, 10, 2) -> 1, 3, 5, 7, 9
# >> 1
# >> 3
# >> 5
# >> 7
# >> 9
# >> range(10, 20, 3) -> 10, 13, 16, 19
# >> 10
# >> 13
# >> 16
# >> 19

# Цикл while ("пока") позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Условие записывается после ключевого слова while и проверяется до выполнения тела цикла.
# Цикл while используется, когда невозможно определить точное количество повторений цикла.
# i = 0 # объявление переменной i для условия цикла
# while i < 5: # ключевое слово 'while' и условие выполнение цикла
#     # тело цикла
#     print(i) # вывод значения переменной i
#     i += 1 # увеличение значения переменной i на единицу
# # Вывод:
# >> 0
# >> 1
# >> 2
# >> 3
# >> 4
# Цикл while может быть бесконечным.
# i = 0
# while True: # условие всегда истинно
#     print(i)
#     i += 1
# # Вывод:
# >> 0
# >> 1
# >> 2
# >> 3
# >> 4
# ...
# >> 999
# ...
# Это может продолжаться долго...
# Выполнение цикла можно прерывать с помощью оператора break.
# i = 0
# while 1: # условие всегда истинно
#     if i == 3: # если i равно 3, то вызываем оператор break
#         break # оператор break прерывает выполнение цикла
#     print(i)
#     i += 1
# # Вывод:
# >> 0
# >> 1
# >> 2
# Оператор continue начинает повторение цикла заново.
# i = 0
# while i < 5:
#     i += 1 #
#     if i % 2 == 1: # если значение i нечетно, то вызываем оператор continue
#         continue # оператор continue начинает повторение цикла заново
#     # в случае вызова continue код ниже не выполнится
#     print(i)
# Вывод:
# >> 0
# >> 2
# >> 4
# Как и для цикла for, для цикла while мы можем записать конструкцию else.
# x = 1
# while x < 5:
#     print(x)
#     x += 1
# else:
#     print('Цикл завершен')
# Вывод:
# >> 1
# >> 2
# >> 3
# >> 4
# >> Цикл завершен
# Примеры
# 1. Числа от A до B
# Пользователь вводит числа A и B (A > B). Выведите все числа от A до B включительно.
# A = int(input('Введите число: '))
# B = int(input('Введите число: '))
# while A >= B:
#     print(A)
#     A -= 1
# # Ввод:
# >> 12
# >> 7
# # Вывод:
# >> 12
# >> 11
# >> 10
# >> 9
# >> 8
# >> 7
# Ввод:
# >> 5
# >> 2
# Вывод:
# >> 5
# >> 4
# >> 3
# >> 2
# 2. Много чисел
# Пользователь вводит числа до тех пор, пока не введет 0.
# Выведите количество введенных чисел (0 считать не нужно).
# n = int(input('Введите число: '))
# counter = 0 # счетчик введенных чисел
# while n: # n неявно преобразуется в тип bool
#     # если n равно 0, то выполнение цикла прервется
#     n = int(input('Введите число: ')) # вводим очередное число
#     counter += 1 # увеличиваем счетчик
# print(f'Количество чисел {counter}')
# # Ввод:
# >> 1
# >> 10
# >> 100
# >> 1000
# >> 0
# Вывод:
# >> Количество чисел 4
# 3. Наименьший делитель
# # Пользователь вводит число N (N > 1). Выведите его наименьший делитель.
# N = int(input('Введите число: '))
# div = 2
# while N % div != 0:
#     div += 1
# print(f'Наименьший делитель равен {div}')
# Ввод:
# >> 10
# Вывод:
# >> Наименьший делитель равен 2
# Ввод:
# >> 15
# Вывод:
# >> Наименьший делитель равен 3
# Ввод:
# >> 17
# Вывод:
# >> Наименьший делитель равен 17

# Список - это непрерывная динамическая коллекция элементов. Каждому элементу списка присваивается порядковый номер - его индекс. Первый индекс равен нулю, второй - единице и так далее. Основные операции для работы со списками - это индексирование, срезы, добавление и удаление элементов, а также проверка на наличие элемента в последовательности.

# Создание пустого списка выглядит так:

# empty_list = []

# Создадим список, состоящий из нескольких чисел:

# numbers = [40, 20, 90, 11, 5]

# Настало время строковых переменных:

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']

# Не будем забывать и о дробях:

# fractions = [3.14, 2.72, 1.41, 1.73, 17.9]

# Мы можем создать список, состоящий из различных типов данных:

# values = [3.14, 10, 'Hello world!', False, 'Python is the best']

# И такое возможно (⊙_⊙)

# list_of_lists = [[2, 4, 0], [11, 2, 10], [0, 19, 27]]

# Индексирование
# Что же такое индексирование? Это загадочное слово обозначает операцию обращения к элементу по его порядковому номеру ( ( ･ω･)ア напоминаю, что нумерация начинается с нуля). Проиллюстрируем это на примере:

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# print(fruits[0])
# print(fruits[1])
# print(fruits[4])

# >>> Apple
# >>> Grape
# >>> Orange

# Списки в Python являются изме­няемым типом данных. Мы можем изменять содер­жимое каждой из ячеек:

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# fruits[0] = 'Watermelon'
# fruits[3] = 'Lemon'
# print(fruits)

# >>> ['Watermelon', 'Grape', 'Peach', 'Lemon', 'Orange']

# Индексирование работает и в обратную сторону. Как такое возможно? Всё просто, мы обра­щаемся к элементу списка по отрица­тельному индексу. Индекс с номе­ром -1 дает нам доступ к после­днему элементу, -2 к предпоследнему и так далее.

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# print(fruits[-1])
# print(fruits[-2])
# print(fruits[-3])
# print(fruits[-4])

# >>> Orange
# >>> Banan
# >>> Peach
# >>> Grape

# Создание списка с помощью list()
# Переходим к способам создания списка. Самый простой из них был приведен выше. Еще раз для закрепления:

# smiles = ['(ಠ_ಠ)', '(￣﹃￣)', '( ͡° ͜ʖ ͡°)', '(╮°-°)╮']

# А есть еще способы? Да, есть. Один из них — создание списка с помощью функции list() В неё мы можем передать любой итерируемый объект (да-да, тот самый по которому можно запустить цикл (• ᵕ •) )

# Рассмотрим несколько примеров:

# letters = list('abcdef')
# numbers = list(range(10))
# even_numbers = list(range(0, 10, 2))
# print(letters)
# print(numbers)
# print(even_numbers)

# >>> ['a', 'b', 'c', 'd', 'e', 'f'
# >>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# >>> [0, 2, 4, 6, 8]

# Длина списка
# С созданием списка вроде ра­зобрались. Следующий вопрос: как узнать длину списка? Можно, конечно, просто посчитать количество элементов... (⊙_⊙) Но есть способ получше! Функция len() возвращает длину любой итерируемой переменной, переменной, по которой можно запустить цикл. Рассмотрим пример:

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# print(len(fruits))

# >>> 5

# numbers = [40, 20, 90]
# print(len(numbers))

# >>> 3

# "...любой итерируемой", а это значит:

# string = 'Hello world'
# print(len(string))
# # 11

# >>> 11

# print(len(range(10))

# >>> 10

# Срезы
# В начале статьи что-то гово­рилось о "срезах". Давайте разберем подробнее, что это такое. Срезом называется неко­торая подпос­ледователь­ность. Принцип действия срезов очень прост: мы "отре­заем" кусок от исходной последова­тель­ности элемента, не меняя её при этом. Я сказал "последо­вательность", а не "спи­сок", потому что срезы работают и с другими итерируемыми типами данных, например, со строками.

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# part_of_fruits = fruits[0:3]
# print(part_of_fruits)

# >>> ['Apple', 'Grape', 'Peach']

# Детально рассмотрим синтаксис срезов:

# итерируемая_переменная[начальный_индекс:конечный_индекс - 1:длина_шага]

# Обращаю ваше внимание, что мы делаем срез от начального индекса до конечного индекса - 1. То есть i = начальный_индекс и i < конечный индекс

# Больше примеров!

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# print(fruits[0:1])
# # Если начальный индекс равен 0, то его можно опустить
# print(fruits[:2])
# print(fruits[:3])
# print(fruits[:4])
# print(fruits[:5])
# # Если конечный индекс равен длине списка, то его тоже можно опустить
# print(fruits[:len(fruits)])
# print(fruits[::])

# >>> ['Apple']
# >>> ['Apple', 'Grape']
# >>> ['Apple', 'Grape', 'Peach']
# >>> ['Apple', 'Grape', 'Peach', 'Banan']
# >>> ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# >>> ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# >>> ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']

# Самое время понять, что делает третий параметр среза - длина шага!

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# print(fruits[::2])
# print(fruits[::3])
# # Длина шага тоже может быть отрицательной!
# print(fruits[::-1])
# print(fruits[4:2:-1])
# print(fruits[3:1:-1])

# >>> ['Apple', 'Peach', 'Orange']
# >>> ['Apple', 'Banan']
# >>> ['Orange', 'Banan', 'Peach', 'Grape', 'Apple']
# >>> ['Orange', 'Banan']
# >>> ['Banan', 'Peach']

# А теперь вспоминаем всё, что мы знаем о циклах. В Python их целых два! Цикл for и цикл while Нас интересует цикл for, с его помощью мы можем перебирать зна­чения и индексы наших последовательностей. Начнем с перебора значений:

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# for fruit in fruits:
#     print(fruit, end=' ')

# >>> Apple Grape Peach Banan Orange

# Выглядит несложно, правда? В переменную fruit объявлен­ную в цикле по очереди записываются значения всех элементов списка fruits

# А что там с перебором индексов?

# for index in range(len(fruits)):
#     print(fruits[index], end=' ')

# Этот пример гораздо интереснее предыдущего! Что же здесь происходит? Для начала разбе­ремся, что делает функция range(len(fruits))

# Мы с вами знаем, что функция len() возвращает длину списка, а range() генерирует диапазон целых чисел от 0 до len()-1.

# Сложив 2+2, мы получим, что переменная index принимает значения в диапазоне от 0 до len()-1. Идем дальше, fruits[index] - это обращение по индексу к элементу с индексом index списка fruits. А так как переменная index принимает значения всех индексов списка fruits, то в цикле мы переберем значения всех элементов нашего списка!

# Операция in
# С помощью in мы можем проверить наличие элемента в списке, строке и любой другой итерируемой переменной.

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# if 'Apple' in fruits:
#     print('В списке есть элемент Apple')

# >>> В списке есть элемент Apple

# fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# if 'Lemon' in fruits:
#     print('В списке есть элемент Lemon')
# else:'
#     print('В списке НЕТ элемента Lemon')

# >>> В списке НЕТ элемента Lemon

# Приведу более сложный пример:

# all_fruits = ['Apple', 'Grape', 'Peach', 'Banan', 'Orange']
# my_favorite_fruits = ['Apple', 'Banan', 'Orange']
# for item in all_fruits:
#     if item in my_favorite_fruits:
#         print(item + ' is my favorite fruit')
#     else:
#         print('I do not like ' + item)

# >>> Apple is my favorite fruit
# >>> I do not like Grape
# >>> I do not like Peach
# >>> Banan is my favorite fruit
# >>> Orange is my favorite fruit

# Методы для работы со списками
# Начнем с метода append(), который добавляет элемент в конец списка:

# # Создаем список, состоящий из четных чисел от 0 до 8 включительно
# numbers = list(range(0,10,2))
# # Добавляем число 200 в конец списка
# numbers.append(200)
# numbers.append(1)
# numbers.append(2)
# numbers.append(3)
# print(numbers)

# >>> [0, 2, 4, 6, 8, 200, 1, 2, 3]

# Мы можем передавать методу append() абсолютно любые значения:

# all_types = [10, 3.14, 'Python', ['I', 'am', 'list']]
# all_types.append(1024)
# all_types.append('Hello world!')
# all_types.append([1, 2, 3])
# print(all_types)

# >>> [10, 3.14, 'Python', ['I', 'am', 'list'], 1024, 'Hello world!', [1, 2, 3]]

# Метод append() отлично выпол­няет свою функцию. Но, что делать, если нам нужно добавить элемент в сере­дину списка? Это умеет метод insert(). Он добавляет элемент в список на произ­вольную позицию. insert() принимает в качестве первого аргу­мента позицию, на которую нужно вставить элемент, а вторым — сам элемент.

# # Создадим список чисел от 0 до 9
# numbers = list(range(10))
# # Добавление элемента 999 на позицию с индексом 0
# numbers.insert(0, 999)
# print(numbers) # первый print
# numbers.insert(2, 1024)
# print(numbers) # второй print
# numbers.insert(5, 'Засланная строка-шпион')
# print(numbers) # третий print

# >>> [999, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # первый print
# >>> [999, 0, 1024, 1, 2, 3, 4, 5, 6, 7, 8, 9] # второй print
# >>> [999, 0, 1024, 1, 2, 'Засланная строка-шпион', 3, 4, 5, 6, 7, 8, 9] # третий print

# Отлично! Добавлять элементы в список мы научи­лись, осталось понять, как их из него удалять. Метод pop() удаляет эле­мент из списка по его индексу:

# numbers = list(range(10))
# print(numbers) # 1
# # Удаляем первый элемент
# numbers.pop(0)
# print(numbers) # 2
# numbers.pop(0)
# print(numbers) # 3
# numbers.pop(2)
# print(numbers) # 4
# # Чтобы удалить последний элемент, вызовем метод pop без аргументов
# numbers.pop()
# print(numbers) # 5
# numbers.pop()
# print(numbers) # 6

# >>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 1
# >>> [1, 2, 3, 4, 5, 6, 7, 8, 9] # 2
# >>> [2, 3, 4, 5, 6, 7, 8, 9] # 3
# >>> [2, 3, 5, 6, 7, 8, 9] # 4
# >>> [2, 3, 5, 6, 7, 8] # 5
# >>> [2, 3, 5, 6, 7] # 6

# Теперь мы знаем, как удалять элемент из списка по его инде­ксу. Но что, если мы не знаем индекса элемента, но знаем его значение? Для такого случая у нас есть метод remove(), кото­рый удаляет пер­вый найденный по значению элемент в списке.

# all_types = [10, 'Python', 10, 3.14, 'Python', ['I', 'am', 'list']]
# all_types.remove(3.14)
# print(all_types) # 1
# all_types.remove(10)
# print(all_types) # 2
# all_types.remove('Python')
# print(all_types) # 3

# >>> [10, 'Python', 10, 'Python', ['I', 'am', 'list']] # 1
# >>> ['Python', 10, 'Python', ['I', 'am', 'list']] # 2
# >>> [10, 'Python', ['I', 'am', 'list']] # 3

# А сейчас немного посчитаем, посчитаем эле­менты списка с помощью метода count()

# numbers = [100, 100, 100, 200, 200, 500, 500, 500, 500, 500, 999]
# print(numbers.count(100)) # 1
# print(numbers.count(200)) # 2
# print(numbers.count(500)) # 3
# print(numbers.count(999)) # 4

# >>> 3 # 1
# >>> 2 # 2
# >>> 5 # 3
# >>> 1 # 4

# В программировании, как и в жизни, проще работать с упоря­доченными дан­ными, в них легче ори­енти­ро­ваться и что-либо искать. Метод sort() сорти­рует список по воз­раста­нию значений его элементов.

# numbers = [100, 2, 11, 9, 3, 1024, 567, 78]
# numbers.sort()
# print(numbers) # 1
# fruits = ['Orange', 'Grape', 'Peach', 'Banan', 'Apple']
# fruits.sort()
# print(fruits) # 2

# >>> [2, 3, 9, 11, 78, 100, 567, 1024] # 1
# >>> ['Apple', 'Banan', 'Grape', 'Orange', 'Peach'] # 2

# Мы можем изменять порядок сортировки с помощью пара­метра reverse. По умол­чанию этот параметр равен False

# fruits = ['Orange', 'Grape', 'Peach', 'Banan', 'Apple']
# fruits.sort()
# print(fruits) # 1
# fruits.sort(reverse=True)
# print(fruits) # 2

# >>> ['Apple', 'Banan', 'Grape', 'Orange', 'Peach'] # 1
# >>> ['Peach', 'Orange', 'Grape', 'Banan', 'Apple'] # 2

# Иногда нам нужно перевернуть список, не спраши­вайте меня зачем... Для этого в самом лучшем языке прог­рам­миро­вания на этой планете JavaScr..­Python есть метод reverse():

# numbers = [100, 2, 11, 9, 3, 1024, 567, 78]
# numbers.reverse()
# print(numbers) # 1
# fruits = ['Orange', 'Grape', 'Peach', 'Banan', 'Apple']
# fruits.reverse()
# print(fruits) # 2

# >>> [78, 567, 1024, 3, 9, 11, 2, 100] # 1
# >>> ['Apple', 'Banan', 'Peach', 'Grape', 'Orange'] # 2

# Допустим, у нас есть два списка и нам нужно их объединить. Програм­мисты на C++ cразу же кинулись писать циклы for, но мы пишем на python, а в python у спис­ков есть полез­ный метод extend(). Этот метод вызы­вается для одного списка, а в качестве аргу­мента ему пере­дается другой список, extend() запи­сывает в конец первого из них начало вто­рого:

# fruits = ['Banana', 'Apple', 'Grape']
# vegetables = ['Tomato', 'Cucumber', 'Potato', 'Carrot']
# fruits.extend(vegetables)
# print(fruits)

# >>> ['Banana', 'Apple', 'Grape', 'Tomato', 'Cucumber', 'Potato', 'Carrot']

# В природе существует специ­аль­ный метод для очистки списка — clear()

# fruits = ['Banana', 'Apple', 'Grape']
# vegetables = ['Tomato', 'Cucumber', 'Potato', 'Carrot']
# fruits.clear()
# vegetables.clear()
# print(fruits)
# print(vegetables)

# >>> []
# >>> []

# Осталось совсем чуть-чуть всего лишь пара мето­дов, так что делаем последний рывок! Метод index() возв­ращает индекс эле­мента. Рабо­тает это так: вы пере­даете в качестве аргу­мента в index() значение элемента, а метод возв­ращает его индекс:

# fruits = ['Banana', 'Apple', 'Grape']
# print(fruits.index('Apple'))
# print(fruits.index('Banana'))
# print(fruits.index('Grape'))

# >>> 1
# >>> 0
# >>> 2

# Финишная прямая! Метод copy(), только не падайте, копирует список и возвра­щает его брата-близнеца. Вообще, копи­ро­вание списков - это тема доста­точно инте­ресная, давай­те рас­смотрим её по-подробнее.

# Во-первых, если мы просто прис­воим уже сущест­вующий список новой пере­менной, то на первый взгляд всё выглядит неплохо:

# fruits = ['Banana', 'Apple', 'Grape']
# new_fruits = fruits
# print(fruits)
# print(new_fruits)

# >>> ['Banana', 'Apple', 'Grape']
# >>> ['Banana', 'Apple', 'Grape']

# Но есть одно маленькое "НО":

# fruits = ['Banana', 'Apple', 'Grape']
# new_fruits = fruits
# fruits.pop()
# print(fruits)
# print(new_fruits)

# # Внезапно, из списка new_fruits исчез последний элемент
# >>> ['Banana', 'Apple']
# >>> ['Banana', 'Apple']

# При прямом присваивании спис­ков копи­рования не проис­ходит. Обе пере­менные начи­нают ссылаться на один и тот же список! То есть если мы изме­ним один из них, то изме­нится и другой. Что же тогда делать? Пользоваться методом copy(), конечно:

# fruits = ['Banana', 'Apple', 'Grape']
# new_fruits = fruits.copy()
# fruits.pop()
# print(fruits)
# print(new_fruits)

# >>> ['Banana', 'Apple']
# >>> ['Banana', 'Apple', 'Grape']

# Отлично! Но что если у нас список в списке? Скопируется ли внутренний список с помощью метода copy() — нет:

# fruits = ['Banana', 'Apple', 'Grape', ['Orange','Peach']]
# new_fruits = fruits.copy()
# fruits[-1].pop()
# print(fruits) # 1
# print(new_fruits) # 2

# >>> ['Banana', 'Apple', 'Grape', ['Orange']] # 1
# >>> ['Banana', 'Apple', 'Grape', ['Orange']] # 2

# Функция - это именованный блок кода, к которому можно обратиться из лю­бого места программы. У функции есть имя и список входных парамет­ров, а также воз­вращаемое значение.

# Функция позволяет использо­вать в про­грамме один и тот же фрагмент кода нес­колько раз.

# Oбъявление функции в Python выглядит так:

# def function_name(argument1, argument2, ...):
#     # код функции
# # def - DEclare Function - "объявить функцию"
# # function_name - имя функции
# # (argument1, argument2, ...) - список аргументов, поступающих на вход функции при ее вызове
# # тело функции - это весь код, который идет после двоеточия

# # Объявление функции

# def hello(name):
#     print('Hello, ' + name)

# # Вызовы функции

# hello('Max')
# hello('Ivan')
# hello('Alex')
# hello('Kate')

# # Вывод

# >> Hello, Max
# >> Hello, Ivan
# >> Hello, Alex
# >> Hello, Kate

# Оператор return возвращает значение из функции.

# Представьте себе обычный калькулятор. Вы вводите первое число, операцию и второе число. Калькулятор возвращает нам результат операции над этими числами. Всё просто, не так ли? Функции точно так же умеют возвращать значение с помощью специального оператора return.

# # Объявление функции

# def sum2(a, b):
#     return a + b

# # Вызовы функции

# s1 = sum2(10, 2)
# s2 = sum2(108, 100)
# s3 = sum2(3, 1)

# print(f's1 = {s1}')
# print(f's2 = {s2}')
# print(f's3 = {s3}')

# >> s1 = 12
# >> s2 = 208
# >> s3 = 4

# # Функция умножения двух чисел

# def mult2(a, b):
#     return a * b

# # Вызовем нашу функцию

# m1 = mult2(10, 2)
# m2 = mult2(108, 100)
# m3 = mult2(3, 1)

# print(f'm1 = {m1}')
# print(f'm2 = {m2}')
# print(f'm3 = {m3}')

# >> m1 = 20
# >> m2 = 10800
# >> m3 = 3

# Для параметров функции можно указывать значения по умолчанию. Это дает возможность вызывать функцию с меньшим числом параметров.

# # Аргумент name по умолчанию равен 'world'

# def hello(name='world'):
#     print('Hello, ' + name)

# hello()
# hello('Ivan')

# >> Hello, world
# >> Hello, Ivan

# Примеры
# 1. Квадрат
# # Написать функцию square(), вычисляющую квадрат числа.

# def square(number):
#     return number * number # Возвращаем результат работы функции обратно в программу

# a = square(2)
# print(a)

# >> 4

# 2. Периметр
# # Напишите функцию perimetr, вычисляющую периметр прямоугольника со сторонами a и b.

# def perimetr(a, b):
#     return 2 * (a + b)

# p = perimetr(4, 3)
# print(p)

# >> 14

# 3. Четное число
# # Напишите функцию isEven, возвращающую True, если число четное, и False, если - нечетное.

# def isEven(x):
#     return x % 2 == 0

# print(isEven(10))
# print(isEven(11))

# >> True
# >> False

# 4. Сумма списка
# # Напишите функцию amountList, которая возвращает сумму всех элементов списка.

# def amountList(lst):
#     amount = 0
#     for x in lst:
#         amount += x
#     return amount

# print(amountList([1, 2, 3]))

# mylist = [1, 2, 4, 8, 16]
# s = amountList(mylist)

# print(f'Сумма списка {mylist} равна {s}')

# >> 6
# >> Сумма списка [1, 2, 4, 8, 16] равна 31

# 5. Фибоначчи
# # Напишите функцию fib, которая возвращает n-ное число Фибоначчи.
# # Последовательность Фибоначчи выглядит так: 1 1 2 3 5 8 13 21 34

# def fib(n):
#     a, b = 0, 1
#     if n == 0: return 0
#     for i in range(1, n):
#         a, b = b, a + b
#     return b

# print(fib(2))
# print(fib(3))
# print(fib(4))
# print(fib(5))
# print(fib(10))

# >> 1
# >> 2
# >> 3
# >> 5
# >> 55

# 6. Факториал
# # Напишите функцию fact, вычисляющую значение факториала числа N.
# # Факториал числа - это произведение всех чисел от 1 до N.
# # Например, факториал числа 5 равен 120 (5! = 120).

# def fact(n):
#     result = 1
#     while n > 1:
#         result *= n
#         n -= 1
#     return result
# print(fact(2))
# print(fact(3))
# print(fact(4))
# print(fact(5))
# >> 2
# >> 6
# >> 24
# >> 120

# Словарь — неупорядоченная структура данных, которая позволяет хранить пары «ключ — значение».

# # Создание словаря c помощью литерала

# student = {'name': 'Ivan', 'age': 12}
# credentials = {'email': 'hacker1337@mail.ru', 'password': '123456'}

# # Создание словаря c помощью функции dict()

# student = dict(name='Ivan', age=12)
# credentials = dict(email='hacker1337@mail.ru', password='123456')

# Для получения значения конкретного ключа используются квадратные скобки [].

# # Получаем значение с ключом 'name'

# student = dict(name='Ivan', age=12)
# print(student['name']) # -> Ivan

# Обновление существующих значений происходит абсолютно также.

# # Получаем значение с ключом 'name'

# student = dict(name='Ivan', age=12)
# student['name'] = 'Vasya'

# print(student['name']) # -> Vasya

# Для удаления ключа и соответствующего значения из словаря можно использовать del

# # Удаление ключа 'age'

# student = dict(name='Ivan', age=12)
# del student['age']

# print(student) # -> {'name': 'Ivan'}

# Метод get() возвращает значение по указанному ключу. Если указанного ключа не существует, метод вернёт None. Также можно указать значение по умолчанию, которое будет возвращено вместо None, если ключа в словаре не окажется.

# # Использование метода get()

# student = dict(name='Ivan', age=12)

# print(student.get('name'))     # -> Ivan
# print(student.get('lastname')) # -> None
# print(student.get('lastname', 'No key')) # -> No key

# Метод pop() удаляет ключ и возвращает соответствующее ему значение.

# # Использование метода pop()

# sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

# model = sneakers.pop('model')

# print(sneakers) # -> {'brand': 'Adidas', 'price': '9990 RUB'}
# print(model)    # -> Nite Jogger

# Метод keys() возвращает специальную коллекцию ключей в словаре.

# # Использование метода keys()

# sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

# print(sneakers.keys()) # -> dict_keys(['brand', 'price', 'model'])

# # dict_keys - это неизменяемая коллекция элементов.

# keys = list(sneakers.keys())
# print(keys) # -> ['brand', 'price', 'model']

# Метод values() возвращает специальную коллекцию значений в словаре.

# # Использование метода values()

# sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

# print(sneakers.values()) # -> dict_values(['Adidas', '9990 RUB', 'Nite Jogger'])

# # dict_values - это неизменяемая коллекция элементов.

# values = list(sneakers.values())
# print(values) # -> ['Adidas', '9990 RUB', 'Nite Jogger']

# Метод items() возвращает пары «ключ — значение» в формате кортежей.

# # Использование метода items()

# sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

# print(sneakers.items()) # -> dict_items([('brand', 'Adidas'), ('price', '9990 RUB'), ('model', 'Nite Jogger')])

# # dict_items - это неизменяемая коллекция элементов.

# items = list(sneakers.items())
# print(items) # -> [('brand', 'Adidas'), ('price', '9990 RUB'), ('model', 'Nite Jogger')]

# sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

# # Вывод ключей словаря с помощью цикла for

# for key in sneakers:
#     print(key)

# # -> brand
# # -> price
# # -> model

# # Вывод значений словаря с помощью цикла for

# for value in sneakers.values():
#     print(value)

# # -> Adidas
# # -> 9990 RUB
# # -> Nite Jogger

# # Вывод ключей и значений словаря с помощью цикла for

# for key, value in sneakers.items():
#     print(key, value)

# # -> brand Adidas
# # -> price 9990 RUB
# # -> model Nite Jogger

# Метод setdefault() возвращает значение ключа, но если его нет, создает ключ с указанным значением (по умолчанию None).

# # Метод setdefault()

# student = dict(name='Ivan', age=12)
# student.setdefault('lastname', 'Ivanov')

# print(student) # -> {'name': 'Ivan', 'age': 12, 'lastname': 'Ivanov'}

# Решение задач
# 1. Пользователь
# # Пользователь вводит имя, фамилия, возраст. Создайте словарь user и запишите данные пользователя в него.
# firstname = input('Enter your firstname: ')
# lastname = input('Enter your lastname: ')
# age = input('Enter your age: ')

# user = dict(firstname=firstname, lastname=lastname, age=age)
# print(user)

# 2. Найти слово
# # Выведите самое часто встречающееся слово в введенной строке.
# list_of_words = ['hello', 'hello', 'hi']
# words = {}

# for word in list_of_words:
#     words[word] = words.get(word, 0) + 1

# # Функция max может получать функцию в качестве второго аргумента
# freq_word = max(words, key=words.get)

# print(freq_word)