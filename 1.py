# 1. Переменные и типы данных
# Целые числа (int): например, x = 5
# Числа с плавающей точкой (float): например, y = 3.14
# Строки (str): например, name = "Alice"
# Булевы значения (bool): True или False
# 2. Операторы
# Арифметические операторы: +, -, *, /, // (целочисленное деление), % (остаток от деления)
# Операторы сравнения: ==, !=, >, <, >=, <=
# 3. Условия
# age = 18
# if age >= 18:
    # print("Вы совершеннолетний.")
# else:
    # print("Вы несовершеннолетний.")
# 4. Циклы
# Цикл for:
# for i in range(5):
#     print(i)  # Выводит числа от 0 до 4
# Цикл while:
# count = 0
# while count < 5:
#     print(count)
#     count += 1  # Увеличивает count на 1

# 2. Функции
# Функции позволяют вам группировать код, который выполняет определенную задачу, и вызывать его по мере необходимости. Это помогает сделать код более организованным и повторно используемым.
# Определение функции
# Вы можете определить функцию с помощью ключевого слова def, за которым следует имя функции и круглые скобки. Вот базовый пример:

# def greet(name):
#     print(f"Привет, {name}!")
# Вызов функции
# После определения функции вы можете вызвать ее, передав необходимые аргументы:
# greet("Алиса")  # Вывод: Привет, Алиса!
# Функции с возвращаемыми значениями
# Функции могут также возвращать значения с помощью ключевого слова return:
# def add(a, b):
#     return a + b
# result = add(5, 3)
# print(result)  # Вывод: 8

# 3. Списки и кортежи
# Списки
# Списки — это изменяемые (можно изменять их содержимое) коллекции, которые могут содержать элементы разных типов. Вы можете создавать списки, используя квадратные скобки [].
# Пример создания списка:
# fruits = ["яблоко", "банан", "вишня"]
# Добавление элементов в список:
# fruits.append("апельсин")  # Добавляет "апельсин" в конец списка
# Доступ к элементам списка:
# print(fruits[0])  # Вывод: яблоко
# Цикл по списку:
# for fruit in fruits:
#     print(fruit)
# Кортежи
# Кортежи — это неизменяемые коллекции, которые также могут содержать элементы разных типов. Вы создаете кортежи, используя круглые скобки ().
# Пример создания кортежа:
# coordinates = (10, 20)
# Доступ к элементам кортежа:
# print(coordinates[0])  # Вывод: 10

# Методы списков
# append(item): Добавляет элемент в конец списка.
# fruits.append("апельсин")
# extend(iterable): Расширяет список, добавляя элементы из другого итерируемого объекта.
# fruits.extend(["груша", "киви"])
# insert(index, item): Вставляет элемент на указанную позицию.
# fruits.insert(1, "манго")  # Вставляет "манго" на индекс 1
# remove(item): Удаляет первый элемент с указанным значением.
# fruits.remove("банан")
# pop(index): Удаляет элемент по указанному индексу и возвращает его. Если индекс не указан, удаляет и возвращает последний элемент.
# last_fruit = fruits.pop()  # Удаляет и возвращает последний элемент
# sort(): Сортирует список на месте.
# fruits.sort()
# reverse(): Разворачивает список на месте.
# fruits.reverse()
# count(item): Возвращает количество вхождений элемента в список.
# count_of_apples = fruits.count("яблоко")
# index(item): Возвращает индекс первого вхождения элемента.
# index_of_banana = fruits.index("банан")
# Методы кортежей
# Кортежи имеют меньше методов, так как они неизменяемы, но вы можете использовать:
# count(item): Возвращает количество вхождений элемента в кортеже.
# coordinates = (10, 20, 10)
# count_of_tens = coordinates.count(10)  # Вернет 2
# index(item): Возвращает индекс первого вхождения элемента в кортеже.
# index_of_twenty = coordinates.index(20)  # Вернет 1
# 4. Словари и множества
# Словари
# Словари в   — это изменяемые коллекции, которые хранят пары "ключ-значение". Словари создаются с помощью фигурных скобок {}.
# Пример создания словаря:
# person = {
#     "name": "Алиса",
#     "age": 30,
#     "city": "Москва"
# }
# Доступ к значениям:
# Вы можете получить значение по ключу:
# print(person["name"])  # Вывод: Алиса
# Добавление и изменение элементов:
# person["age"] = 31  # Изменяет возраст
# person["job"] = "инженер"  # Добавляет новую пару ключ-значение
# Удаление элемента:
# del person["city"]  # Удаляет ключ "city"
# Методы словарей:
# keys(): Возвращает список всех ключей.
# values(): Возвращает список всех значений.
# items(): Возвращает список всех пар "ключ-значение".
# Множества
# Множества в   — это неупорядоченные коллекции уникальных элементов. Они создаются с помощью фигурных скобок {} или с помощью функции set().
# Пример создания множества:
# fruits_set = {"яблоко", "банан", "вишня"}
# Добавление элементов:
# fruits_set.add("апельсин")  # Добавляет "апельсин"
# Удаление элементов:
# fruits_set.remove("банан")  # Удаляет "банан"
# Операции с множествами:
# Объединение: set1 | set2
# Пересечение: set1 & set2
# Разность: set1 - set2

# Методы словарей
# get(key): Возвращает значение по ключу. Если ключ не найден, возвращает None или заданное значение по умолчанию.
# age = person.get("age")  # Вернет 30
# keys(): Возвращает представление всех ключей в словаре.
# keys = person.keys()  # Вернет dict_keys(['name', 'age', 'job'])
# values(): Возвращает представление всех значений в словаре.
# values = person.values()  # Вернет dict_values(['Алиса', 31, 'инженер'])
# items(): Возвращает представление всех пар "ключ-значение" в словаре.
# items = person.items()  # Вернет dict_items([('name', 'Алиса'), ('age', 31), ('job', 'инженер')])
# pop(key): Удаляет элемент по ключу и возвращает его значение. Если ключ не найден, вызывает ошибку.
# job = person.pop("job")  # Удаляет и возвращает значение по ключу "job"
# clear(): Удаляет все элементы из словаря.
# person.clear()  # Теперь person пустой
# copy(): Возвращает поверхностную копию словаря.
# person_copy = person.copy()
# Методы множеств
# add(item): Добавляет элемент в множество.
# fruits_set.add("апельсин")
# remove(item): Удаляет элемент из множества. Если элемент не найден, вызывает ошибку.
# fruits_set.remove("банан")
# discard(item): Удаляет элемент из множества, но не вызывает ошибку, если элемент не найден.
# fruits_set.discard("банан")  # Не вызовет ошибку, если "банан" отсутствует
# pop(): Удаляет и возвращает произвольный элемент из множества. Если множество пусто, вызывает ошибку.
# fruit = fruits_set.pop()
# clear(): Удаляет все элементы из множества.
# fruits_set.clear()
# union(other_set): Возвращает новое множество, содержащее элементы из обоих множеств.
# combined = fruits_set.union(other_set)
# intersection(other_set): Возвращает новое множество с элементами, которые есть в обоих множествах.
# common = fruits_set.intersection(other_set)
# difference(other_set): Возвращает новое множество с элементами, которые есть в первом множестве, но отсутствуют во втором.
# diff = fruits_set.difference(other_set)
# 5. Обработка ошибок и исключений
# В   вы можете обрабатывать ошибки с помощью конструкции try и except. Это позволяет вашему коду продолжать выполнение даже в случае возникновения ошибок.
# Основная структура
# try:
#     # Код, который может вызвать ошибку
#     result = 10 / 0  # Это вызовет ошибку деления на ноль
# except ZeroDivisionError:
#     # Код, который выполняется в случае ошибки
#     print("Ошибка: Деление на ноль!")
# Обработка нескольких исключений
# Вы можете обрабатывать несколько типов исключений, указав их через запятую:
# try:
#     value = int(input("Введите число: "))
#     result = 10 / value
# except ValueError:
#     print("Ошибка: Введено не число!")
# except ZeroDivisionError:
#     print("Ошибка: Деление на ноль!")
# Блок else
# Вы можете использовать блок else, который выполняется, если в блоке try не возникло ошибок:
# try:
#     value = int(input("Введите число: "))
#     result = 10 / value
# except ValueError:
#     print("Ошибка: Введено не число!")
# except ZeroDivisionError:
#     print("Ошибка: Деление на ноль!")
# else:
#     print(f"Результат: {result}")
# Блок finally
# Блок finally выполняется в любом случае, независимо от того, возникла ошибка или нет. Это полезно для освобождения ресурсов или выполнения завершающих действий:
# try:
#     file = open("file.txt", "r")
#     # Работа с файлом
# except FileNotFoundError:
#     print("Ошибка: Файл не найден!")
# finally:
#     file.close()  # Закрываем файл, если он был открыт
# 9. Обработка ошибок и исключений
# Исключения — это ошибки, которые возникают во время выполнения программы. 
# Обработка исключений позволяет избежать аварийного завершения программы и управлять ошибками.
# Пример обработки исключения:
# try:
    # Код, который может вызвать исключение
    # result = 10 / 0  # Деление на ноль вызывает ошибку
# except ZeroDivisionError:
    # Код, который выполняется, если произошло исключение
    # print("Ошибка: Деление на ноль!")
# finally:
    # Код, который выполняется в любом случае
    # print("Этот блок выполняется всегда.")
# Вы также можете использовать оператор raise для генерации исключений:
# raise ValueError("Это сообщение об ошибке.")
# 6. Файловый ввод-вывод
# В   вы можете работать с файлами для чтения и записи данных. Вот основные операции, которые вы можете выполнять:
# Открытие файла
# Для открытия файла используется функция open(), которая принимает два аргумента: имя файла и режим открытия.
# Режимы открытия:
# 'r': Чтение (по умолчанию).
# 'w': Запись (создает новый файл или перезаписывает существующий).
# 'a': Добавление (добавляет данные в конец файла).
# 'b': Двоичный режим (например, 'rb' или 'wb' для работы с бинарными файлами).
# Пример открытия файла для чтения:
# file = open("example.txt", "r")
# Чтение из файла
# Чтение из файла
# Вы можете читать данные из файла с помощью методов:
# read(size): Читает указанное количество байтов. Если size не указан, читает весь файл.
# readline(): Читает одну строку из файла.
# readlines(): Читает все строки и возвращает их в виде списка.
# with open("example.txt", "r") as file:
#     content = file.read()
#     print(content)
# Запись в файл
# Для записи данных в файл используйте метод write().
# Пример записи в файл:
# with open("example.txt", "w") as file:
#     file.write("Hello, World!\n")
#     file.write("Это новая строка.")
# Закрытие файла
# Важно закрывать файл после завершения работы с ним, чтобы освободить ресурсы. Это можно сделать с помощью метода close(), но лучше использовать контекстный менеджер with, который автоматически закроет файл.
# Пример закрытия файла:
# file.close()  # Закрывает файл
# 7. Модули и пакеты
# В   модули и пакеты позволяют организовывать код и использовать его повторно. Вот основные моменты, которые стоит знать:
# Что такое модуль?
# Модуль — это файл с кодом  , который может содержать функции, классы и переменные. Вы можете импортировать модули в свои программы, чтобы использовать их функциональность.
# Импортирование модулей
# Вы можете импортировать модуль с помощью ключевого слова import.
# Пример импорта модуля:
# import math
# print(math.sqrt(16))  # Вывод: 4.0
# Импортирование отдельных функций
# Вы можете импортировать конкретные функции из модуля, чтобы не указывать имя модуля каждый раз.
# Пример:
# from math import sqrt
# print(sqrt(25))  # Вывод: 5.0
# Псевдонимы для модулей
# Вы можете использовать as, чтобы задать псевдоним для модуля, что может упростить его использование.
# Пример:
# import numpy as np
# array = np.array([1, 2, 3])
# print(array)
# Создание собственного модуля
# Вы можете создать свой модуль, просто сохранив файл с расширением .py. Например, создайте файл mymodule.py:
# # mymodule.py
# def greet(name):
#     return f"Привет, {name}!"
# Затем импортируйте его в другом файле:
# import mymodule
# print(mymodule.greet("Алиса"))  # Вывод: Привет, Алиса!
# Пакеты
# Пакет — это коллекция модулей в одной директории. Чтобы создать пакет, создайте папку и добавьте в нее файл __init__.py. Этот файл может быть пустым или содержать код, который будет выполняться при импорте пакета.
# Пример структуры пакета:
# my_package/
#     __init__.py
#     module1.py
#     module2.py
# Вы можете импортировать модули из пакета следующим образом:
# from my_package import module1

# 8. Итераторы и генераторы
# Итераторы — это объекты, которые позволяют перебрать элементы коллекции (например, списков, кортежей) 
# без необходимости знать, как они хранятся в памяти.
# Пример создания итератора:
# my_list = [1, 2, 3]
# my_iterator = iter(my_list)
# print(next(my_iterator))  # Вывод: 1
# print(next(my_iterator))  # Вывод: 2
# print(next(my_iterator))  # Вывод: 3
# print(next(my_iterator))  # Вызывает StopIteration, если элементов больше нет
# Генераторы — это специальный тип итераторов, которые позволяют создавать итераторы с помощью функции.
# Генераторы используют ключевое слово yield для возврата значений.
# def count_up_to(n):
    # count = 1
    # while count <= n:
        # yield count
        # count += 1
# for number in count_up_to(5):
    # print(number)  # Вывод: 1 2 3 4 5
    
    # Дополнения к итераторам и генераторам
    
    # 1. Создание собственного итератора:
    # class MyIterator:
    #     def __init__(self, max):
    #         self.max = max
    #         self.current = 0
    
    #     def __iter__(self):
    #         return self
    
    #     def __next__(self):
    #         if self.current < self.max:
    #             self.current += 1
    #             return self.current
    #         else:
    #             raise StopIteration
    
    # # Использование собственного итератора:
    # for num in MyIterator(5):
    #     print(num)  # Вывод: 1 2 3 4 5
    
    # # 2. Генераторы выражений:
    # squares = (x * x for x in range(6))
    # for square in squares:
    #     print(square)  # Вывод: 0 1 4 9 16 25
    
    # # 3. Использование модуля itertools:
    # import itertools
    
    # # Пример использования count:
    # for i in itertools.count(10):
    #     if i > 15:
    #         break
    #     print(i)  # Вывод: 10 11 12 13 14 15
    
# 9. Декораторы
# Декораторы — это функции, которые позволяют изменять поведение других функций. 
# Они часто используются для добавления функциональности к существующим функциям без изменения их кода.

# Пример простого декоратора:
# def my_decorator(func):
    # def wrapper():
        # print("Что-то происходит перед вызовом функции.")
        # func()
        # print("Что-то происходит после вызова функции.")
    # return wrapper

# Использование декоратора:
# @my_decorator
# def say_hello():
    # print("Привет!")
# Вызов функции с декоратором:
# say_hello()
# Вывод:
# Что-то происходит перед вызовом функции.
# Привет!
# Что-то происходит после вызова функции.
# Декораторы могут принимать аргументы:
# def repeat(num_times):
#     def decorator_repeat(func):
#         def wrapper(*args, **kwargs):
#             for _ in range(num_times):
#                 func(*args, **kwargs)
#         return wrapper
#     return decorator_repeat
# @repeat(3)
# def greet(name):
#     print(f"Привет, {name}!")
# Вызов функции с декоратором:
# greet("Алиса")  # Вывод: Привет, Алиса! (3 раза)

# 10. Контекстные менеджеры
# Контекстные менеджеры — это удобный способ управления ресурсами, такими как файлы, 
# сетевые соединения и блокировки. Они гарантируют, что ресурсы будут правильно освобождены после использования.
# Пример использования контекстного менеджера для работы с файлами:
# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)  # Содержимое файла будет выведено

# Контекстный менеджер автоматически закроет файл после выхода из блока with,
# даже если возникнет ошибка.

# Вы также можете создавать свои собственные контекстные менеджеры, используя класс с методами __enter__ и __exit__:
# class MyContextManager:
#     def __enter__(self):
#         print("Вход в контекст")
#         return self  # Возвращает объект, который будет доступен в блоке with

#     def __exit__(self, exc_type, exc_val, exc_tb):
#         print("Выход из контекста")
#         # Здесь можно обработать исключения, если они произошли
#         return False  # Если True, исключение будет подавлено

# Использование собственного контекстного менеджера:
# with MyContextManager() as cm:
#     print("Внутри контекста")

# 11. Многопоточность и асинхронное программирование
# Многопоточность позволяет выполнять несколько потоков (параллельных задач) одновременно в одном процессе.
# Это полезно для выполнения задач, которые могут занимать много времени, например, сетевые запросы или операции ввода-вывода.

# import threading
# import time

# # Пример использования потоков:
# def print_numbers():
#     for i in range(5):
#         print(i)
#         time.sleep(1)

# # Создание и запуск потока:
# thread = threading.Thread(target=print_numbers)
# thread.start()

# # Основной поток продолжает выполнение:
# for i in range(5, 10):
#     print(i)
#     time.sleep(1)

# # Ожидание завершения потока:
# thread.join()

# # Асинхронное программирование позволяет выполнять задачи, не блокируя основной поток.
# # Это особенно полезно для ввода-вывода, когда программа может ждать ответа от внешних источников.

# import asyncio

# # Пример асинхронной функции:
# async def say_after(delay, message):
#     await asyncio.sleep(delay)
#     print(message)

# # Основная асинхронная функция:
# async def main():
#     await say_after(1, "Привет!")
#     await say_after(2, "Как дела?")
    
# # Запуск асинхронной программы:
# asyncio.run(main())

